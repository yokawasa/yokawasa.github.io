<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>SOCKSプロキシを経由したAzure VNETプライベートリソースへのアクセス | unofficialism</title>
<meta name=keywords content="openssh,chrome,firefox,SOCKS,AzureVNET,VPN"><meta name=description content="UPDATED 2017-03-22: Added SOCKS Proxy Configuration for Internet Explorer
外部からの接続（SSH、HTTPなど）を受け付けていないAzure 仮想ネットワーク(以下VNET)内のリソースにSOCKSプロキシを経由して外部からアクセスしましょうというお話。本記事ではAzure VNET内の外部からのアクセス許可していないVMへのSSHログインとHTTPサーバコンテンツへのブラウジングの2つの方法を紹介する。
SOCKS(RFC1928) とはさまざまなアプリケーションが間にファイアーウォールを挟んでいても安全に快適にやり取りができるようにすることを目的として作られたプロトコルのことで、SOCKSプロキシはSOCKSプロトコルを受け取りファイアウォール内外との接続を可能にするものである。エンドポイントやNetwork Security Group (NSG)によりネットーワーク分離設定されたAzure VNET内のリソースに対して一時的に本来直接アクセス許可しないネットワークからアクセスが必要な状況はあるかと思う。そのような時に毎回設定変更で必要なプロトコル、アクセス先に対して穴をあけるのは非常に面倒であり、またサイト間VPN、ポイント対サイトVPNとなるとさらに手間がかかる。お手軽に、もしくは定常的ではないが一時的に内部リソースにアクセスしたい場合にSOCKSプロキシ経由でのアクセスを検討してみてはいかがだろうか。以下はSOCKSプロキシ経由によるAzure VNET内のプライベートリソースへのアクセスイメージである。
SOCKSプロキシの作成 まずはOpenSSHのダイナミックポートフォワード機能を使ってSOCKSプロキシを作成する。ダイナミックポートフォワードはSSHをSOCKSプロキシとして振舞うことを可能にする。SSHでアクセス先ホストと DynamicFoward(-D)でポートを指定することでlocalhostにSOCKSプロキシが立ち上がり指定のTCPポート(SOCKSプロキシサーバは基本的は1080だが、割り当て可能なポートであればどのポートでもOK)をlocalhost側からログイン先ホストのSSHサーバに転送することができるようになる。もちろん経路は暗号化される。現状のサポートプロトコルはSOCKS4とSOCKS5。
例えば上図でいうとJump Server(踏み台)にDynamicFoward(-D)1080でログインすると、Jump Serverにポート1080を転送するSOCKSプロキシが localhostに立ち上がり、そのlocalhost:1080に対してSOCKS4またはSOCKS5プロトコルで接続することでJump Serverを経由して通信を行うことができるようになる。
localhostポート1080のJump Serverへのダイナミックフォワードは次のように-Dオプションで行う。
$ ssh -2 -D 1080 -l [Account] [Jump Server] 毎回-Dオプション指定が面倒な場合は、次のようにconfg(ssh_config)にDynamicForwardの記述することも可能。
~/.ssh/config
Host JumpServer User [Account名] HostName/IP [Jump Serverホスト/IPアドレス] Protocol 2 ForwardAgent yes DynamicForward 1080 上記OpenSSHの設定は、Linux/Macの場合は標準Terminalを使えばよいが、Windowsの場合はCygwin、XmingなどX端末エミュレータソフトをインストールしていただく必要がある。またX端末エミュレーターをインストールしなくともWindowsでは有名なSSHクライアントソフトPuttyがダイナミックポートフォワードに対応しているためPuttyを使ってSOCKSプロキシ作成することも可能。詳しくは「Dynamic Port Forwarding with SOCKS over SSH」が参考になるかと。
SOCKSプロキシを使ったSSH接続 次に上記で作成したSOCKSプロキシを経由してVNET内のサーバにSSH接続をする。 netcatでSOCKSプロキシを経由してlocalhostから目的のVNET内サーバ（ServerX）間にnetcatトンネルを作成してServerXにはそのnetcatトンネルを通じて接続する。
local$ ssh -2 -l [Account] -o 'ProxyCommand nc -x localhost:1080 %h %p' [ServerX] netcat のプロキシ指定は-xオプションで行う。 ここでは事前に作成したSOCKSプロキシ(localhost:1080)を指定。 netcatトンネルの作成コマンドはProxyCommandに記述する。こちらも毎回長いオプション入力を避けるために config（ssh_config）設定すると便利である。"><meta name=author content="Yoichi Kawasaki"><link rel=canonical href=https://yokawasa.github.io/posts/accessing-private-resource-in-azure-vnet-via-socks-proxy/><link crossorigin=anonymous href=https://yokawasa.github.io/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=https://yokawasa.github.io/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://yokawasa.github.io/profile.png><link rel=icon type=image/png sizes=16x16 href=https://yokawasa.github.io/profile.png><link rel=icon type=image/png sizes=32x32 href=https://yokawasa.github.io/profile.png><link rel=apple-touch-icon href=https://yokawasa.github.io/profile.png><link rel=mask-icon href=https://yokawasa.github.io/profile.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://yokawasa.github.io/posts/accessing-private-resource-in-azure-vnet-via-socks-proxy/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="SOCKSプロキシを経由したAzure VNETプライベートリソースへのアクセス | unofficialism"><meta property="og:description" content="UPDATED 2017-03-22: Added SOCKS Proxy Configuration for Internet Explorer
外部からの接続（SSH、HTTPなど）を受け付けていないAzure 仮想ネットワーク(以下VNET)内のリソースにSOCKSプロキシを経由して外部からアクセスしましょうというお話。本記事ではAzure VNET内の外部からのアクセス許可していないVMへのSSHログインとHTTPサーバコンテンツへのブラウジングの2つの方法を紹介する。
SOCKS(RFC1928) とはさまざまなアプリケーションが間にファイアーウォールを挟んでいても安全に快適にやり取りができるようにすることを目的として作られたプロトコルのことで、SOCKSプロキシはSOCKSプロトコルを受け取りファイアウォール内外との接続を可能にするものである。エンドポイントやNetwork Security Group (NSG)によりネットーワーク分離設定されたAzure VNET内のリソースに対して一時的に本来直接アクセス許可しないネットワークからアクセスが必要な状況はあるかと思う。そのような時に毎回設定変更で必要なプロトコル、アクセス先に対して穴をあけるのは非常に面倒であり、またサイト間VPN、ポイント対サイトVPNとなるとさらに手間がかかる。お手軽に、もしくは定常的ではないが一時的に内部リソースにアクセスしたい場合にSOCKSプロキシ経由でのアクセスを検討してみてはいかがだろうか。以下はSOCKSプロキシ経由によるAzure VNET内のプライベートリソースへのアクセスイメージである。
SOCKSプロキシの作成 まずはOpenSSHのダイナミックポートフォワード機能を使ってSOCKSプロキシを作成する。ダイナミックポートフォワードはSSHをSOCKSプロキシとして振舞うことを可能にする。SSHでアクセス先ホストと DynamicFoward(-D)でポートを指定することでlocalhostにSOCKSプロキシが立ち上がり指定のTCPポート(SOCKSプロキシサーバは基本的は1080だが、割り当て可能なポートであればどのポートでもOK)をlocalhost側からログイン先ホストのSSHサーバに転送することができるようになる。もちろん経路は暗号化される。現状のサポートプロトコルはSOCKS4とSOCKS5。
例えば上図でいうとJump Server(踏み台)にDynamicFoward(-D)1080でログインすると、Jump Serverにポート1080を転送するSOCKSプロキシが localhostに立ち上がり、そのlocalhost:1080に対してSOCKS4またはSOCKS5プロトコルで接続することでJump Serverを経由して通信を行うことができるようになる。
localhostポート1080のJump Serverへのダイナミックフォワードは次のように-Dオプションで行う。
$ ssh -2 -D 1080 -l [Account] [Jump Server] 毎回-Dオプション指定が面倒な場合は、次のようにconfg(ssh_config)にDynamicForwardの記述することも可能。
~/.ssh/config
Host JumpServer User [Account名] HostName/IP [Jump Serverホスト/IPアドレス] Protocol 2 ForwardAgent yes DynamicForward 1080 上記OpenSSHの設定は、Linux/Macの場合は標準Terminalを使えばよいが、Windowsの場合はCygwin、XmingなどX端末エミュレータソフトをインストールしていただく必要がある。またX端末エミュレーターをインストールしなくともWindowsでは有名なSSHクライアントソフトPuttyがダイナミックポートフォワードに対応しているためPuttyを使ってSOCKSプロキシ作成することも可能。詳しくは「Dynamic Port Forwarding with SOCKS over SSH」が参考になるかと。
SOCKSプロキシを使ったSSH接続 次に上記で作成したSOCKSプロキシを経由してVNET内のサーバにSSH接続をする。 netcatでSOCKSプロキシを経由してlocalhostから目的のVNET内サーバ（ServerX）間にnetcatトンネルを作成してServerXにはそのnetcatトンネルを通じて接続する。
local$ ssh -2 -l [Account] -o 'ProxyCommand nc -x localhost:1080 %h %p' [ServerX] netcat のプロキシ指定は-xオプションで行う。 ここでは事前に作成したSOCKSプロキシ(localhost:1080)を指定。 netcatトンネルの作成コマンドはProxyCommandに記述する。こちらも毎回長いオプション入力を避けるために config（ssh_config）設定すると便利である。"><meta property="og:type" content="article"><meta property="og:url" content="https://yokawasa.github.io/posts/accessing-private-resource-in-azure-vnet-via-socks-proxy/"><meta property="og:image" content="https://yokawasa.github.io/assets/20150818-Accessing-AzureVNET-via-SOCKSProxy.jpg"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-08-18T11:16:03+00:00"><meta property="article:modified_time" content="2015-08-18T11:16:03+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://yokawasa.github.io/assets/20150818-Accessing-AzureVNET-via-SOCKSProxy.jpg"><meta name=twitter:title content="SOCKSプロキシを経由したAzure VNETプライベートリソースへのアクセス | unofficialism"><meta name=twitter:description content="UPDATED 2017-03-22: Added SOCKS Proxy Configuration for Internet Explorer
外部からの接続（SSH、HTTPなど）を受け付けていないAzure 仮想ネットワーク(以下VNET)内のリソースにSOCKSプロキシを経由して外部からアクセスしましょうというお話。本記事ではAzure VNET内の外部からのアクセス許可していないVMへのSSHログインとHTTPサーバコンテンツへのブラウジングの2つの方法を紹介する。
SOCKS(RFC1928) とはさまざまなアプリケーションが間にファイアーウォールを挟んでいても安全に快適にやり取りができるようにすることを目的として作られたプロトコルのことで、SOCKSプロキシはSOCKSプロトコルを受け取りファイアウォール内外との接続を可能にするものである。エンドポイントやNetwork Security Group (NSG)によりネットーワーク分離設定されたAzure VNET内のリソースに対して一時的に本来直接アクセス許可しないネットワークからアクセスが必要な状況はあるかと思う。そのような時に毎回設定変更で必要なプロトコル、アクセス先に対して穴をあけるのは非常に面倒であり、またサイト間VPN、ポイント対サイトVPNとなるとさらに手間がかかる。お手軽に、もしくは定常的ではないが一時的に内部リソースにアクセスしたい場合にSOCKSプロキシ経由でのアクセスを検討してみてはいかがだろうか。以下はSOCKSプロキシ経由によるAzure VNET内のプライベートリソースへのアクセスイメージである。
SOCKSプロキシの作成 まずはOpenSSHのダイナミックポートフォワード機能を使ってSOCKSプロキシを作成する。ダイナミックポートフォワードはSSHをSOCKSプロキシとして振舞うことを可能にする。SSHでアクセス先ホストと DynamicFoward(-D)でポートを指定することでlocalhostにSOCKSプロキシが立ち上がり指定のTCPポート(SOCKSプロキシサーバは基本的は1080だが、割り当て可能なポートであればどのポートでもOK)をlocalhost側からログイン先ホストのSSHサーバに転送することができるようになる。もちろん経路は暗号化される。現状のサポートプロトコルはSOCKS4とSOCKS5。
例えば上図でいうとJump Server(踏み台)にDynamicFoward(-D)1080でログインすると、Jump Serverにポート1080を転送するSOCKSプロキシが localhostに立ち上がり、そのlocalhost:1080に対してSOCKS4またはSOCKS5プロトコルで接続することでJump Serverを経由して通信を行うことができるようになる。
localhostポート1080のJump Serverへのダイナミックフォワードは次のように-Dオプションで行う。
$ ssh -2 -D 1080 -l [Account] [Jump Server] 毎回-Dオプション指定が面倒な場合は、次のようにconfg(ssh_config)にDynamicForwardの記述することも可能。
~/.ssh/config
Host JumpServer User [Account名] HostName/IP [Jump Serverホスト/IPアドレス] Protocol 2 ForwardAgent yes DynamicForward 1080 上記OpenSSHの設定は、Linux/Macの場合は標準Terminalを使えばよいが、Windowsの場合はCygwin、XmingなどX端末エミュレータソフトをインストールしていただく必要がある。またX端末エミュレーターをインストールしなくともWindowsでは有名なSSHクライアントソフトPuttyがダイナミックポートフォワードに対応しているためPuttyを使ってSOCKSプロキシ作成することも可能。詳しくは「Dynamic Port Forwarding with SOCKS over SSH」が参考になるかと。
SOCKSプロキシを使ったSSH接続 次に上記で作成したSOCKSプロキシを経由してVNET内のサーバにSSH接続をする。 netcatでSOCKSプロキシを経由してlocalhostから目的のVNET内サーバ（ServerX）間にnetcatトンネルを作成してServerXにはそのnetcatトンネルを通じて接続する。
local$ ssh -2 -l [Account] -o 'ProxyCommand nc -x localhost:1080 %h %p' [ServerX] netcat のプロキシ指定は-xオプションで行う。 ここでは事前に作成したSOCKSプロキシ(localhost:1080)を指定。 netcatトンネルの作成コマンドはProxyCommandに記述する。こちらも毎回長いオプション入力を避けるために config（ssh_config）設定すると便利である。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://yokawasa.github.io/posts/"},{"@type":"ListItem","position":2,"name":"SOCKSプロキシを経由したAzure VNETプライベートリソースへのアクセス","item":"https://yokawasa.github.io/posts/accessing-private-resource-in-azure-vnet-via-socks-proxy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"SOCKSプロキシを経由したAzure VNETプライベートリソースへのアクセス","name":"SOCKSプロキシを経由したAzure VNETプライベートリソースへのアクセス","description":"UPDATED 2017-03-22: Added SOCKS Proxy Configuration for Internet Explorer\n外部からの接続（SSH、HTTPなど）を受け付けていないAzure 仮想ネットワーク(以下VNET)内のリソースにSOCKSプロキシを経由して外部からアクセスしましょうというお話。本記事ではAzure VNET内の外部からのアクセス許可していないVMへのSSHログインとHTTPサーバコンテンツへのブラウジングの2つの方法を紹介する。\nSOCKS(RFC1928) とはさまざまなアプリケーションが間にファイアーウォールを挟んでいても安全に快適にやり取りができるようにすることを目的として作られたプロトコルのことで、SOCKSプロキシはSOCKSプロトコルを受け取りファイアウォール内外との接続を可能にするものである。エンドポイントやNetwork Security Group (NSG)によりネットーワーク分離設定されたAzure VNET内のリソースに対して一時的に本来直接アクセス許可しないネットワークからアクセスが必要な状況はあるかと思う。そのような時に毎回設定変更で必要なプロトコル、アクセス先に対して穴をあけるのは非常に面倒であり、またサイト間VPN、ポイント対サイトVPNとなるとさらに手間がかかる。お手軽に、もしくは定常的ではないが一時的に内部リソースにアクセスしたい場合にSOCKSプロキシ経由でのアクセスを検討してみてはいかがだろうか。以下はSOCKSプロキシ経由によるAzure VNET内のプライベートリソースへのアクセスイメージである。\nSOCKSプロキシの作成 まずはOpenSSHのダイナミックポートフォワード機能を使ってSOCKSプロキシを作成する。ダイナミックポートフォワードはSSHをSOCKSプロキシとして振舞うことを可能にする。SSHでアクセス先ホストと DynamicFoward(-D)でポートを指定することでlocalhostにSOCKSプロキシが立ち上がり指定のTCPポート(SOCKSプロキシサーバは基本的は1080だが、割り当て可能なポートであればどのポートでもOK)をlocalhost側からログイン先ホストのSSHサーバに転送することができるようになる。もちろん経路は暗号化される。現状のサポートプロトコルはSOCKS4とSOCKS5。\n例えば上図でいうとJump Server(踏み台)にDynamicFoward(-D)1080でログインすると、Jump Serverにポート1080を転送するSOCKSプロキシが localhostに立ち上がり、そのlocalhost:1080に対してSOCKS4またはSOCKS5プロトコルで接続することでJump Serverを経由して通信を行うことができるようになる。\nlocalhostポート1080のJump Serverへのダイナミックフォワードは次のように-Dオプションで行う。\n$ ssh -2 -D 1080 -l [Account] [Jump Server] 毎回-Dオプション指定が面倒な場合は、次のようにconfg(ssh_config)にDynamicForwardの記述することも可能。\n~/.ssh/config\nHost JumpServer User [Account名] HostName/IP [Jump Serverホスト/IPアドレス] Protocol 2 ForwardAgent yes DynamicForward 1080 上記OpenSSHの設定は、Linux/Macの場合は標準Terminalを使えばよいが、Windowsの場合はCygwin、XmingなどX端末エミュレータソフトをインストールしていただく必要がある。またX端末エミュレーターをインストールしなくともWindowsでは有名なSSHクライアントソフトPuttyがダイナミックポートフォワードに対応しているためPuttyを使ってSOCKSプロキシ作成することも可能。詳しくは「Dynamic Port Forwarding with SOCKS over SSH」が参考になるかと。\nSOCKSプロキシを使ったSSH接続 次に上記で作成したSOCKSプロキシを経由してVNET内のサーバにSSH接続をする。 netcatでSOCKSプロキシを経由してlocalhostから目的のVNET内サーバ（ServerX）間にnetcatトンネルを作成してServerXにはそのnetcatトンネルを通じて接続する。\nlocal$ ssh -2 -l [Account] -o \u0026#39;ProxyCommand nc -x localhost:1080 %h %p\u0026#39; [ServerX] netcat のプロキシ指定は-xオプションで行う。 ここでは事前に作成したSOCKSプロキシ(localhost:1080)を指定。 netcatトンネルの作成コマンドはProxyCommandに記述する。こちらも毎回長いオプション入力を避けるために config（ssh_config）設定すると便利である。","keywords":["openssh","chrome","firefox","SOCKS","AzureVNET","VPN"],"articleBody":"UPDATED 2017-03-22: Added SOCKS Proxy Configuration for Internet Explorer\n外部からの接続（SSH、HTTPなど）を受け付けていないAzure 仮想ネットワーク(以下VNET)内のリソースにSOCKSプロキシを経由して外部からアクセスしましょうというお話。本記事ではAzure VNET内の外部からのアクセス許可していないVMへのSSHログインとHTTPサーバコンテンツへのブラウジングの2つの方法を紹介する。\nSOCKS(RFC1928) とはさまざまなアプリケーションが間にファイアーウォールを挟んでいても安全に快適にやり取りができるようにすることを目的として作られたプロトコルのことで、SOCKSプロキシはSOCKSプロトコルを受け取りファイアウォール内外との接続を可能にするものである。エンドポイントやNetwork Security Group (NSG)によりネットーワーク分離設定されたAzure VNET内のリソースに対して一時的に本来直接アクセス許可しないネットワークからアクセスが必要な状況はあるかと思う。そのような時に毎回設定変更で必要なプロトコル、アクセス先に対して穴をあけるのは非常に面倒であり、またサイト間VPN、ポイント対サイトVPNとなるとさらに手間がかかる。お手軽に、もしくは定常的ではないが一時的に内部リソースにアクセスしたい場合にSOCKSプロキシ経由でのアクセスを検討してみてはいかがだろうか。以下はSOCKSプロキシ経由によるAzure VNET内のプライベートリソースへのアクセスイメージである。\nSOCKSプロキシの作成 まずはOpenSSHのダイナミックポートフォワード機能を使ってSOCKSプロキシを作成する。ダイナミックポートフォワードはSSHをSOCKSプロキシとして振舞うことを可能にする。SSHでアクセス先ホストと DynamicFoward(-D)でポートを指定することでlocalhostにSOCKSプロキシが立ち上がり指定のTCPポート(SOCKSプロキシサーバは基本的は1080だが、割り当て可能なポートであればどのポートでもOK)をlocalhost側からログイン先ホストのSSHサーバに転送することができるようになる。もちろん経路は暗号化される。現状のサポートプロトコルはSOCKS4とSOCKS5。\n例えば上図でいうとJump Server(踏み台)にDynamicFoward(-D)1080でログインすると、Jump Serverにポート1080を転送するSOCKSプロキシが localhostに立ち上がり、そのlocalhost:1080に対してSOCKS4またはSOCKS5プロトコルで接続することでJump Serverを経由して通信を行うことができるようになる。\nlocalhostポート1080のJump Serverへのダイナミックフォワードは次のように-Dオプションで行う。\n$ ssh -2 -D 1080 -l [Account] [Jump Server] 毎回-Dオプション指定が面倒な場合は、次のようにconfg(ssh_config)にDynamicForwardの記述することも可能。\n~/.ssh/config\nHost JumpServer User [Account名] HostName/IP [Jump Serverホスト/IPアドレス] Protocol 2 ForwardAgent yes DynamicForward 1080 上記OpenSSHの設定は、Linux/Macの場合は標準Terminalを使えばよいが、Windowsの場合はCygwin、XmingなどX端末エミュレータソフトをインストールしていただく必要がある。またX端末エミュレーターをインストールしなくともWindowsでは有名なSSHクライアントソフトPuttyがダイナミックポートフォワードに対応しているためPuttyを使ってSOCKSプロキシ作成することも可能。詳しくは「Dynamic Port Forwarding with SOCKS over SSH」が参考になるかと。\nSOCKSプロキシを使ったSSH接続 次に上記で作成したSOCKSプロキシを経由してVNET内のサーバにSSH接続をする。 netcatでSOCKSプロキシを経由してlocalhostから目的のVNET内サーバ（ServerX）間にnetcatトンネルを作成してServerXにはそのnetcatトンネルを通じて接続する。\nlocal$ ssh -2 -l [Account] -o 'ProxyCommand nc -x localhost:1080 %h %p' [ServerX] netcat のプロキシ指定は-xオプションで行う。 ここでは事前に作成したSOCKSプロキシ(localhost:1080)を指定。 netcatトンネルの作成コマンドはProxyCommandに記述する。こちらも毎回長いオプション入力を避けるために config（ssh_config）設定すると便利である。\n** ~/.ssh/config**\nHost ServerX User [Account] Protocol 2 ForwardAgent yes ProxyCommand nc -x localhost:1080 -w1 %h %p 注意点として、netcatにはGNU本家版とそれ以外にいくつか派生があるが-x オプションの利用可能なnetcatである必要がある。オリジナルのnetcatやGNU netcatには-xオプションはない。ここで使用しているnetcatはIPv6に対応しているOpenBSD netcat。\nもちろんVNET内のVMへのSSH接続の別解としてProxyCommandでJump ServerからServerXへnetcatトンネルを作成してlocalからServerXにログインすることも可能。\nlocal$ ssh -2 -o 'ProxyCommand ssh [Jump Server] nc -w1 %h %p' [ServerX] 実はこの方法のほうがProxyCommand でプロキシ設定を行うため事前に別コンソールで何かを用意する必要がなく間違いなくSOCKSプロキシ経由での接続よりも楽。ではSOCKSプロキシ経由で接続する理由は何か？ 理由は単純で、通常Jump Serverはセキュリティ設定上の理由でログインしてもほとんど何もできないようにするために機能を無効化していることが多く、よってnetcatが使えない(ncはおろかsshコマンド以外ほとんど何も使えない)環境だったりする。この場合、上記で説明したようにSOCKSプロキシ経由でのSSHログインが有効な手段となる。\nSOCKSプロキシ経由でのブラウジング ブラウザーにSOCKSプロキシ対応のプラグインを\t入れることでブラウザーによるプライベートリソース（内部ネットワーク内のアプリ・ミドルウェア等のウェブUIを持った管理ツールなど）の閲覧も可能となる。有名なものにSwitchySharp(Google Chrome)やFoxyproxy(Firefox)などがある。以下簡単な設定スクリーンショットを乗せておく。共に「http://yoichika-.cloudapp.net」なURIパターンの時にのみSOCKSプロキシlocalhost:12345経由でアクセスする設定となっている。\nGoogle Chrome - SwitchySharp\nFirefox - Foxyproxy\nInternet Explorer - Out-of-box feature\nAs answered in Stack Overflow, Internet Explorer does support SOCKS proxies.\nTools \u003e Internet Options \u003e Connections \u003e LAN Settings \u003e Proxy Server \u003e Advanced Enjoy Accessing private resources with SOCKS Proxy!\n","wordCount":"169","inLanguage":"en","datePublished":"2015-08-18T11:16:03Z","dateModified":"2015-08-18T11:16:03Z","author":{"@type":"Person","name":"Yoichi Kawasaki"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://yokawasa.github.io/posts/accessing-private-resource-in-azure-vnet-via-socks-proxy/"},"publisher":{"@type":"Organization","name":"unofficialism","logo":{"@type":"ImageObject","url":"https://yokawasa.github.io/profile.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yokawasa.github.io/ accesskey=h title="unofficialism (Alt + H)">unofficialism</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></div></div><ul id=menu><li><a href=https://yokawasa.github.io/about title=about><span>about</span></a></li><li><a href=https://yokawasa.github.io/posts title=posts><span>posts</span></a></li><li><a href=https://yokawasa.github.io/works title=works><span>works</span></a></li><li><a href=https://yokawasa.github.io/search/ title="search (Alt + /)" accesskey=/><span>search</span></a></li><li><a href=https://yokawasa.github.io/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://yokawasa.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://yokawasa.github.io/posts/>Posts</a></div><h1 class=post-title>SOCKSプロキシを経由したAzure VNETプライベートリソースへのアクセス</h1><div class=post-meta>&lt;span title='2015-08-18 00:00:00 +0000 UTC'>August 18, 2015&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;Yoichi Kawasaki&nbsp;|&nbsp;<a href=https://github.com/yokawasa/yokawasa.github.io/tree/master/content/posts/2015-08-18-accessing-private-resource-in-azure-vnet-via-socks-proxy.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details open><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#socks%e3%83%97%e3%83%ad%e3%82%ad%e3%82%b7%e3%81%ae%e4%bd%9c%e6%88%90 aria-label=SOCKSプロキシの作成>SOCKSプロキシの作成</a></li><li><a href=#socks%e3%83%97%e3%83%ad%e3%82%ad%e3%82%b7%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%9fssh%e6%8e%a5%e7%b6%9a aria-label=SOCKSプロキシを使ったSSH接続>SOCKSプロキシを使ったSSH接続</a></li><li><a href=#socks%e3%83%97%e3%83%ad%e3%82%ad%e3%82%b7%e7%b5%8c%e7%94%b1%e3%81%a7%e3%81%ae%e3%83%96%e3%83%a9%e3%82%a6%e3%82%b8%e3%83%b3%e3%82%b0 aria-label=SOCKSプロキシ経由でのブラウジング>SOCKSプロキシ経由でのブラウジング</a></li></ul></div></details></div><div class=post-content><p>UPDATED 2017-03-22: Added SOCKS Proxy Configuration for Internet Explorer</p><p>外部からの接続（SSH、HTTPなど）を受け付けていないAzure 仮想ネットワーク(以下VNET)内のリソースに<code>SOCKSプロキシ</code>を経由して外部からアクセスしましょうというお話。本記事ではAzure VNET内の外部からのアクセス許可していないVMへのSSHログインとHTTPサーバコンテンツへのブラウジングの2つの方法を紹介する。</p><p>SOCKS(<a href=http://www.ietf.org/rfc/rfc1928.txt>RFC1928</a>) とはさまざまなアプリケーションが間にファイアーウォールを挟んでいても安全に快適にやり取りができるようにすることを目的として作られたプロトコルのことで、<code>SOCKSプロキシ</code>は<code>SOCKSプロトコル</code>を受け取りファイアウォール内外との接続を可能にするものである。エンドポイントや<code>Network Security Group (NSG)</code>によりネットーワーク分離設定されたAzure VNET内のリソースに対して一時的に本来直接アクセス許可しないネットワークからアクセスが必要な状況はあるかと思う。そのような時に毎回設定変更で必要なプロトコル、アクセス先に対して穴をあけるのは非常に面倒であり、またサイト間VPN、ポイント対サイトVPNとなるとさらに手間がかかる。お手軽に、もしくは定常的ではないが一時的に内部リソースにアクセスしたい場合にSOCKSプロキシ経由でのアクセスを検討してみてはいかがだろうか。以下は<code>SOCKSプロキシ</code>経由によるAzure VNET内のプライベートリソースへのアクセスイメージである。</p><p><img loading=lazy src=https://yokawasa.github.io/assets/20150818-Accessing-AzureVNET-via-SOCKSProxy.jpg alt=Accessing-AzureVNET-via-SOCKSProxy></p><h2 id=socksプロキシの作成>SOCKSプロキシの作成<a hidden class=anchor aria-hidden=true href=#socksプロキシの作成>#</a></h2><p>まずは<code>OpenSSH</code>の<code>ダイナミックポートフォワード機能</code>を使って<code>SOCKSプロキシ</code>を作成する。<code>ダイナミックポートフォワード</code>はSSHを<code>SOCKSプロキシ</code>として振舞うことを可能にする。SSHでアクセス先ホストと <code>DynamicFoward(-D)</code>でポートを指定することで<code>localhost</code>にSOCKSプロキシが立ち上がり指定のTCPポート(SOCKSプロキシサーバは基本的は<code>1080</code>だが、割り当て可能なポートであればどのポートでもOK)を<code>localhost</code>側からログイン先ホストのSSHサーバに転送することができるようになる。もちろん経路は暗号化される。現状のサポートプロトコルは<code>SOCKS4</code>と<code>SOCKS5</code>。</p><p>例えば上図でいうとJump Server(踏み台)に<code>DynamicFoward(-D)1080</code>でログインすると、Jump Serverにポート<code>1080</code>を転送するSOCKSプロキシが <code>localhost</code>に立ち上がり、その<code>localhost:1080</code>に対して<code>SOCKS4</code>または<code>SOCKS5</code>プロトコルで接続することでJump Serverを経由して通信を行うことができるようになる。</p><p>localhostポート<code>1080</code>のJump Serverへのダイナミックフォワードは次のように-Dオプションで行う。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>$ ssh -2 -D <span style=color:#ae81ff>1080</span> -l <span style=color:#f92672>[</span>Account<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>Jump Server<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>毎回<code>-Dオプション</code>指定が面倒な場合は、次のように<code>confg(ssh_config)</code>に<code>DynamicForward</code>の記述することも可能。</p><p><strong>~/.ssh/config</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>Host JumpServer</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>User         [Account名]</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>HostName/IP  [Jump Serverホスト/IPアドレス]</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>Protocol 2</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>ForwardAgent  yes</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>DynamicForward 1080</span>
</span></span></code></pre></div><p>上記OpenSSHの設定は、Linux/Macの場合は標準Terminalを使えばよいが、Windowsの場合は<code>Cygwin</code>、<code>Xming</code>などX端末エミュレータソフトをインストールしていただく必要がある。またX端末エミュレーターをインストールしなくともWindowsでは有名なSSHクライアントソフト<code>Putty</code>が<code>ダイナミックポートフォワード</code>に対応しているため<code>Putty</code>を使って<code>SOCKSプロキシ</code>作成することも可能。詳しくは「<a href=http://dimitar.me/dynamic-port-forwarding-with-socks-over-ssh/>Dynamic Port Forwarding with SOCKS over SSH</a>」が参考になるかと。</p><h2 id=socksプロキシを使ったssh接続>SOCKSプロキシを使ったSSH接続<a hidden class=anchor aria-hidden=true href=#socksプロキシを使ったssh接続>#</a></h2><p>次に上記で作成したSOCKSプロキシを経由してVNET内のサーバにSSH接続をする。 <code>netcat</code>で<code>SOCKSプロキシ</code>を経由して<code>localhost</code>から目的のVNET内サーバ（ServerX）間にnetcatトンネルを作成してServerXにはそのnetcatトンネルを通じて接続する。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>local$ ssh -2 -l <span style=color:#f92672>[</span>Account<span style=color:#f92672>]</span> -o <span style=color:#e6db74>&#39;ProxyCommand nc -x localhost:1080 %h %p&#39;</span> <span style=color:#f92672>[</span>ServerX<span style=color:#f92672>]</span>
</span></span></code></pre></div><p><code>netcat</code> のプロキシ指定は<code>-xオプション</code>で行う。 ここでは事前に作成した<code>SOCKSプロキシ</code>(<code>localhost:1080</code>)を指定。 netcatトンネルの作成コマンドは<code>ProxyCommand</code>に記述する。こちらも毎回長いオプション入力を避けるために <code>config（ssh_config）</code>設定すると便利である。</p><p>** ~/.ssh/config**</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#ae81ff>Host ServerX</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>User        [Account]</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>Protocol 2</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>ForwardAgent  yes</span>
</span></span><span style=display:flex><span>   <span style=color:#ae81ff>ProxyCommand nc -x localhost:1080 -w1 %h %p</span>
</span></span></code></pre></div><p>注意点として、netcatにはGNU本家版とそれ以外にいくつか派生があるが-x オプションの利用可能なnetcatである必要がある。オリジナルのnetcatやGNU netcatには-xオプションはない。ここで使用しているnetcatはIPv6に対応しているOpenBSD netcat。</p><p>もちろんVNET内のVMへのSSH接続の別解としてProxyCommandでJump ServerからServerXへnetcatトンネルを作成してlocalからServerXにログインすることも可能。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>local$ ssh -2 -o <span style=color:#e6db74>&#39;ProxyCommand ssh [Jump Server] nc -w1 %h %p&#39;</span> <span style=color:#f92672>[</span>ServerX<span style=color:#f92672>]</span>
</span></span></code></pre></div><p>実はこの方法のほうがProxyCommand でプロキシ設定を行うため事前に別コンソールで何かを用意する必要がなく間違いなくSOCKSプロキシ経由での接続よりも楽。ではSOCKSプロキシ経由で接続する理由は何か？ 理由は単純で、通常Jump Serverはセキュリティ設定上の理由でログインしてもほとんど何もできないようにするために機能を無効化していることが多く、よってnetcatが使えない(ncはおろかsshコマンド以外ほとんど何も使えない)環境だったりする。この場合、上記で説明したようにSOCKSプロキシ経由でのSSHログインが有効な手段となる。</p><h2 id=socksプロキシ経由でのブラウジング>SOCKSプロキシ経由でのブラウジング<a hidden class=anchor aria-hidden=true href=#socksプロキシ経由でのブラウジング>#</a></h2><p>ブラウザーにSOCKSプロキシ対応のプラグインを 入れることでブラウザーによるプライベートリソース（内部ネットワーク内のアプリ・ミドルウェア等のウェブUIを持った管理ツールなど）の閲覧も可能となる。有名なものに<a href=http://www.akiyan.com/blog/archives/2012/10/ultimate-chrome-proxy-change-is-switchy-sharp-for-windows-and-osx.html>SwitchySharp</a>(Google Chrome)や<a href=https://getfoxyproxy.org/sshproxy.html>Foxyproxy</a>(Firefox)などがある。以下簡単な設定スクリーンショットを乗せておく。共に「http://yoichika-<em>.cloudapp.net</em>」なURIパターンの時にのみSOCKSプロキシlocalhost:12345経由でアクセスする設定となっている。</p><p>Google Chrome - SwitchySharp</p><p><img loading=lazy src=https://yokawasa.github.io/assets/20150818-GoogleChrome-SwitcySharp.jpg alt=GoogleChrome-SwitcySharp></p><p>Firefox - Foxyproxy</p><p><img loading=lazy src=https://yokawasa.github.io/assets/20150818-Firefox-FoxyProxyStandard.jpg alt=Firefox-FoxyProxyStandard></p><p>Internet Explorer - Out-of-box feature</p><p>As answered in <a href=http://stackoverflow.com/questions/18375234/enable-socks-4a-5-in-internet-explorer>Stack Overflow</a>, Internet Explorer does support SOCKS proxies.</p><pre tabindex=0><code>Tools &gt; Internet Options &gt; Connections &gt; LAN Settings &gt; Proxy Server &gt; Advanced
</code></pre><p><img loading=lazy src=https://yokawasa.github.io/assets/20150818-IE-SOCKS-PROXY.jpg alt=IE-SOCKS-PROXY></p><p>Enjoy Accessing private resources with SOCKS Proxy!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://yokawasa.github.io/tags/openssh/>Openssh</a></li><li><a href=https://yokawasa.github.io/tags/chrome/>Chrome</a></li><li><a href=https://yokawasa.github.io/tags/firefox/>Firefox</a></li><li><a href=https://yokawasa.github.io/tags/socks/>SOCKS</a></li><li><a href=https://yokawasa.github.io/tags/azurevnet/>AzureVNET</a></li><li><a href=https://yokawasa.github.io/tags/vpn/>VPN</a></li></ul><nav class=paginav><a class=prev href=https://yokawasa.github.io/posts/tips-visual-studio-csharp-merge-exe-and-dll/><span class=title>« Prev</span><br><span>Static linking DLL to EXE in C Sharp</span>
</a><a class=next href=https://yokawasa.github.io/posts/getting-resource-metrics-with-azure-insights-rest-api/><span class=title>Next »</span><br><span>Azure Insights REST APIを使ってAzure各リソースのメトリックを抽出する</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share SOCKSプロキシを経由したAzure VNETプライベートリソースへのアクセス on twitter" href="https://twitter.com/intent/tweet/?text=SOCKS%e3%83%97%e3%83%ad%e3%82%ad%e3%82%b7%e3%82%92%e7%b5%8c%e7%94%b1%e3%81%97%e3%81%9fAzure%20VNET%e3%83%97%e3%83%a9%e3%82%a4%e3%83%99%e3%83%bc%e3%83%88%e3%83%aa%e3%82%bd%e3%83%bc%e3%82%b9%e3%81%b8%e3%81%ae%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9&amp;url=https%3a%2f%2fyokawasa.github.io%2fposts%2faccessing-private-resource-in-azure-vnet-via-socks-proxy%2f&amp;hashtags=openssh%2cchrome%2cfirefox%2cSOCKS%2cAzureVNET%2cVPN"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share SOCKSプロキシを経由したAzure VNETプライベートリソースへのアクセス on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fyokawasa.github.io%2fposts%2faccessing-private-resource-in-azure-vnet-via-socks-proxy%2f&amp;title=SOCKS%e3%83%97%e3%83%ad%e3%82%ad%e3%82%b7%e3%82%92%e7%b5%8c%e7%94%b1%e3%81%97%e3%81%9fAzure%20VNET%e3%83%97%e3%83%a9%e3%82%a4%e3%83%99%e3%83%bc%e3%83%88%e3%83%aa%e3%82%bd%e3%83%bc%e3%82%b9%e3%81%b8%e3%81%ae%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9&amp;summary=SOCKS%e3%83%97%e3%83%ad%e3%82%ad%e3%82%b7%e3%82%92%e7%b5%8c%e7%94%b1%e3%81%97%e3%81%9fAzure%20VNET%e3%83%97%e3%83%a9%e3%82%a4%e3%83%99%e3%83%bc%e3%83%88%e3%83%aa%e3%82%bd%e3%83%bc%e3%82%b9%e3%81%b8%e3%81%ae%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9&amp;source=https%3a%2f%2fyokawasa.github.io%2fposts%2faccessing-private-resource-in-azure-vnet-via-socks-proxy%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share SOCKSプロキシを経由したAzure VNETプライベートリソースへのアクセス on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fyokawasa.github.io%2fposts%2faccessing-private-resource-in-azure-vnet-via-socks-proxy%2f&title=SOCKS%e3%83%97%e3%83%ad%e3%82%ad%e3%82%b7%e3%82%92%e7%b5%8c%e7%94%b1%e3%81%97%e3%81%9fAzure%20VNET%e3%83%97%e3%83%a9%e3%82%a4%e3%83%99%e3%83%bc%e3%83%88%e3%83%aa%e3%82%bd%e3%83%bc%e3%82%b9%e3%81%b8%e3%81%ae%e3%82%a2%e3%82%af%e3%82%bb%e3%82%b9"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg>
</a><a target=_blank rel="noopener noreferrer" aria-label="share SOCKSプロキシを経由したAzure VNETプライベートリソースへのアクセス on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fyokawasa.github.io%2fposts%2faccessing-private-resource-in-azure-vnet-via-socks-proxy%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://yokawasa.github.io/>unofficialism</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>